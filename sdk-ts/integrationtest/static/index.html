<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Microphone to Speaker</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }
      #toggleAudio {
        font-size: 18px;
        padding: 10px 20px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s;
      }
      #toggleAudio:hover {
        background-color: #45a049;
      }
    </style>
  </head>
  <body>
    <button id="toggleAudio">Start Audio</button>

    <script>
      // Create audio context
      const BUFFER_SIZE = 4800;
      class Player {
        constructor() {
          this.playbackNode = null;
        }

        async init(sampleRate) {
          const audioContext = new AudioContext({ sampleRate });
          await audioContext.audioWorklet.addModule(
            "/audio-playback-worklet.js"
          );

          this.playbackNode = new AudioWorkletNode(
            audioContext,
            "audio-playback-worklet"
          );
          this.playbackNode.connect(audioContext.destination);
        }

        play(buffer) {
          if (this.playbackNode) {
            this.playbackNode.port.postMessage(buffer);
          }
        }

        stop() {
          if (this.playbackNode) {
            this.playbackNode.port.postMessage(null);
          }
        }
      }

      class Recorder {
        constructor(onDataAvailable) {
          this.onDataAvailable = onDataAvailable;
          this.audioContext = null;
          this.mediaStream = null;
          this.mediaStreamSource = null;
          this.workletNode = null;
        }

        async start(stream) {
          try {
            if (this.audioContext) {
              await this.audioContext.close();
            }

            this.audioContext = new (window.AudioContext ||
              window.webkitAudioContext)({ sampleRate: 24000 });

            await this.audioContext.audioWorklet.addModule(
              "/audio-processor-worklet.js"
            );

            this.mediaStream = stream;
            this.mediaStreamSource = this.audioContext.createMediaStreamSource(
              this.mediaStream
            );

            this.workletNode = new AudioWorkletNode(
              this.audioContext,
              "audio-processor-worklet"
            );
            this.workletNode.port.onmessage = (event) => {
              this.onDataAvailable(event.data.buffer);
            };

            this.mediaStreamSource.connect(this.workletNode);
            this.workletNode.connect(this.audioContext.destination);
          } catch (error) {
            this.stop();
          }
        }

        async stop() {
          if (this.mediaStream) {
            this.mediaStream.getTracks().forEach((track) => track.stop());
            this.mediaStream = null;
          }

          if (this.audioContext) {
            await this.audioContext.close();
            this.audioContext = null;
          }

          this.mediaStreamSource = null;
          this.workletNode = null;
        }
      }

      // Function to get microphone input and send it to WebSocket
      async function startAudio() {
        try {
          // handle output -> speaker stuff
          const ws = new WebSocket(
            "wss://run.beamlit.dev/main/agents/voiceagent/ws?environment=production&token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImJlYW1saXQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOlsiaHR0cHM6Ly9hcGkuYmVhbWxpdC5kZXYiLCJodHRwczovL2FwaS5iZWFtbGl0LmNvbSIsImh0dHBzOi8vcnVuLmJlYW1saXQuZGV2IiwiaHR0cHM6Ly9ydW4uYmVhbWxpdC5jb20iLCJiZWFtbGl0Il0sImVtYWlsIjoiY3Bsb3Vqb3V4QGJlYW1saXQuY29tIiwiZXhwIjoxNzM4NjA2NTYwLCJmYW1pbHlfbmFtZSI6IiIsImdpdmVuX25hbWUiOiIiLCJpYXQiOjE3Mzg1OTkzNjAsImlzcyI6Imh0dHBzOi8vYXBpLmJlYW1saXQuZGV2L3YwIiwianRpIjoiSzlGUFZPUFVORFVBUktUMSIsIm5iZiI6MTczODU5OTM2MCwic2NvcGUiOiIqIiwic3ViIjoiZjVhODJiYmEtZDNjNS00MmIzLWI2ODYtNTUwNDU3MWNlODY0Iiwic3ViX3R5cGUiOiJ1c2VyIn0.jLMs2qIm5LN6vXPOqKo-BanPlXh5JBbm-Ua2l2PNgGbB4UjLg6fzlAFEBu2JRqIhRKge9jjhwQmppoixtbR5rS-0XuoqHC0qWV7rqZ0oqBtgCSvLeg2Og0-zkZRsXVBGSlI8JoVPa6qojQD26KMG66DHkMOx4uCspbfs764B8mHSn5nCbOgy6mgRSERc39O7WHDhyNIv-rEBRnKgxLTSriGVOjQp10fefJwYlhq7Oy1K4lUOyhC3F4vCEC-ANhI1gI4eN_SVDixCo3QvsewyL6ei1lY3r24XL024uDBTXCiFWjlbO5_bgvp5LzWlMtZLHeOOC_NKMWTbpTTDzeJOZrTkiHrNSQeKsQ6pqJnF05_6S94tiid6FoEvmL9--o5KPNEJaQlwePm6CsNOEzRzp6dx0ik-cobG_FCx_j1CNUscj7bCJ-p48b0C0M4J3eYeJB_zBT5qUHjExIZyk7aSr-SyyqgJB4fZzmb1ZWNsAh3xQN8mMtgThCq4C_oZnk6tyFgEyXrw_aflZ2NXIncKI_f9nZyVZ-HraWnUhC3wWovwZDeI0Z0N9DMR9FNN2ksLY8Kw8t60PDD-GIm9x6cuZ8T6Drx07PEbV2MSZ4zlH1nJxRfmXycchWXB6b9VYEN80Z-yK2D43EYi2mcKNqd8Bk8osYVDJ_JNcVVC0JJMcS0"
          );
          // const ws = new WebSocket("ws://localhost:1338/ws");

          const audioPlayer = new Player();
          audioPlayer.init(24000);

          ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data?.type !== "response.audio.delta") return;

            const binary = atob(data.delta);
            const bytes = Uint8Array.from(binary, (c) => c.charCodeAt(0));
            const pcmData = new Int16Array(bytes.buffer);

            audioPlayer.play(pcmData);
          };

          let buffer = new Uint8Array();

          const appendToBuffer = (newData) => {
            const newBuffer = new Uint8Array(buffer.length + newData.length);
            newBuffer.set(buffer);
            newBuffer.set(newData, buffer.length);
            buffer = newBuffer;
          };

          const handleAudioData = (data) => {
            const uint8Array = new Uint8Array(data);
            appendToBuffer(uint8Array);

            if (buffer.length >= BUFFER_SIZE) {
              const toSend = new Uint8Array(buffer.slice(0, BUFFER_SIZE));
              buffer = new Uint8Array(buffer.slice(BUFFER_SIZE));

              const regularArray = String.fromCharCode(...toSend);
              const base64 = btoa(regularArray);

              ws.send(
                JSON.stringify({
                  type: "input_audio_buffer.append",
                  audio: base64,
                })
              );
            }
          };

          // handle microphone -> input websocket
          const audioRecorder = new Recorder(handleAudioData);
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });

          await audioRecorder.start(stream);
        } catch (error) {
          console.error("Error accessing the microphone", error);
          alert(
            "Error accessing the microphone. Please check your settings and try again."
          );
        }
      }

      // Button to toggle audio
      const toggleButton = document.getElementById("toggleAudio");
      let isAudioOn = false;

      toggleButton.addEventListener("click", async () => {
        if (!isAudioOn) {
          await startAudio();
          toggleButton.textContent = "Stop Audio";
          isAudioOn = true;
        } else {
          // audioContext.suspend();
          toggleButton.textContent = "Start Audio";
          isAudioOn = false;
        }
      });
    </script>
  </body>
</html>
